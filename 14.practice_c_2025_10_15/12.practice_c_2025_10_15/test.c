//第 1 题（单选题）
//题目名称：
//下列程序段的输出结果为（C）
//
//unsigned long pulArray[] = { 6,7,8,9,10 };
//unsigned long* pulPtr;
//pulPtr = pulArray;
//*(pulPtr + 3) += 3;
//printf("%d,%d\n", *pulPtr, *(pulPtr + 3));
//题目内容：
//A .9, 12
//B .6, 9
//C .6, 12
//D .6, 10
// 
//第 2 题（单选题）
//题目名称：
//下面关于指针运算说法正确的是：（C）
//
//题目内容：
//A.整形指针 + 1，向后偏移一个字节
//B.指针 - 指针得到是指针和指针之间的字节个数
//C.整形指针解引用操作访问4个字节
//D.指针不能比较大小
//
//第 4 题（单选题）
//题目名称：
//以下关于指针的说法, 正确的是(C)
//
//题目内容：
//A .int* const p与int const* p等价
//B .const int* p与int* const p等价
//C .const int* p与int const* p等价
//D .int* p[10]与int(*p)[10]等价
// 
//第 5 题（单选题）
//题目名称：
//C语言中哪一种形式声明了一个指向char类型变量的指针p，p的值不可修改，但p指向的变量值可修改？(C)
//
//题目内容：
//A .const char* p
//B .char const* p
//C .char* const p
//D .const char* const p
// 
//第 6 题（多选题）
//题目名称：
//以下哪个操作可以避免野指针的出现？(ABCD)
//
//题目内容：
//A.使用空指针（NULL）初始化指针变量
//B.在指针释放后将其设置为NULL
//C.确保指针始终指向有效的内存地址
//D.检查指针的有效性后再进行访问
// 
//第 7 题（单选题）
//题目名称：
//以下哪个描述最符合野指针的含义？(A)
//
//题目内容：
//A.指向已被释放的内存空间的指针
//B.指向堆栈中的局部变量的指针
//C.指向全局变量的指针
//D.指向动态分配的内存的指针
// 
//第 8 题（单选题）
//题目名称：
//下面关于assert宏的描述哪个是正确的？(D)
//
//题目内容：
//A.assert宏总是会终止程序的执行
//B.assert宏在Release模式下也起作用
//C.assert宏只能用于整数类型的表达式
//D.assert宏可以通过编译选项进行启用或禁用

//第 9 题（单选题）
//题目名称：
//能把函数处理结果的2个数据返回给主调函数，在下面的方法中不正确的是：（A）
//
//题目内容：
//A .return 这2个数
//B.形参用数组
//C.形参用2个指针
//D.用2个全局变量
//答案解析：
//A：错误，一个函数只能返回一个结果
//B：正确，将形参存在数组中，修改数组中内容，可以通过数组将修改结果带出去
//C：正确，形参如果用指针，最终指向的是外部的实参，在函数中对指向指向内容进行修改，改变的就是外部的实参
//D：正确，全局变量不受函数的结束而结束，在函数中改变全局变量，主调函数中可以看到改变之后的结果
//因此，选择A

//第 10 题（单选题）
//题目名称：
//关于函数调用说法不正确的是：（C）
//
//题目内容：
//A.函数可以传值调用，传值调用的时候形参是实参的一份临时拷贝
//B.函数可以传址调用，传址调用的时候，可以通过形参操作实参
//C.函数可以嵌套定义，但是不能嵌套调用
//D.函数可以嵌套调用，但是不能嵌套定义

